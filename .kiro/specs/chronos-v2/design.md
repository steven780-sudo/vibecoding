# Chronos v2.0 - è®¾è®¡æ–‡æ¡£

**é¡¹ç›®åç§°**: Chronos - æœ¬åœ°æ–‡ä»¶æ—¶å…‰æœº v2.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-11-02  
**çŠ¶æ€**: è®¾è®¡é˜¶æ®µ  
**ç‰ˆæœ¬**: 1.0

---

## ğŸ“‹ è®¾è®¡æ¦‚è¿°

æœ¬æ–‡æ¡£æè¿° Chronos v2.0 çš„è¯¦ç»†æŠ€æœ¯è®¾è®¡ï¼ŒåŒ…æ‹¬æ¶æ„ã€æ•°æ®æ¨¡å‹ã€API è®¾è®¡ã€ç»„ä»¶è®¾è®¡ç­‰ã€‚

### è®¾è®¡ç›®æ ‡

1. **ç¨³å®šæ€§ä¼˜å…ˆ**: ä½¿ç”¨æˆç†Ÿç¨³å®šçš„æŠ€æœ¯æ ˆ
2. **é«˜æ€§èƒ½**: æ”¯æŒ 10,000+ æ–‡ä»¶æµç•…æ“ä½œ
3. **é«˜è´¨é‡**: æ¸…æ™°çš„æ¶æ„ï¼Œå®Œå–„çš„æµ‹è¯•
4. **å¯æ‰©å±•**: æ˜“äºæ·»åŠ æ–°åŠŸèƒ½
5. **è·¨å¹³å°**: Windows + macOS

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Chronos v2.0                         â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  æ¨¡å¼ 1: æœ¬åœ° Web åº”ç”¨                             â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚ â”‚
â”‚  â”‚  â”‚ Browser  â”‚  HTTP   â”‚  Node.js Server  â”‚        â”‚ â”‚
â”‚  â”‚  â”‚ (React)  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  (Express)       â”‚        â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚ â”‚
â”‚  â”‚                              â”‚                      â”‚ â”‚
â”‚  â”‚                              â–¼                      â”‚ â”‚
â”‚  â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚ â”‚
â”‚  â”‚                        â”‚ isomorphic-git â”‚        â”‚ â”‚
â”‚  â”‚                        â”‚ SQLite         â”‚        â”‚ â”‚
â”‚  â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  æ¨¡å¼ 2: äº‘ç«¯ Web åº”ç”¨                             â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ â”‚
â”‚  â”‚  â”‚  Browser (React)                     â”‚          â”‚ â”‚
â”‚  â”‚  â”‚  - isomorphic-git (WASM)            â”‚          â”‚ â”‚
â”‚  â”‚  â”‚  - IndexedDB                        â”‚          â”‚ â”‚
â”‚  â”‚  â”‚  - File System Access API           â”‚          â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  æ¨¡å¼ 3: æ¡Œé¢åº”ç”¨                                  â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ â”‚
â”‚  â”‚  â”‚  Electron                            â”‚          â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚          â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ Renderer â”‚    â”‚  Main Process  â”‚ â”‚          â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ (React)  â”‚â—„â”€â”€â–ºâ”‚  (Node.js)     â”‚ â”‚          â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜IPC â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚          â”‚ â”‚
â”‚  â”‚  â”‚                        â”‚             â”‚          â”‚ â”‚
â”‚  â”‚  â”‚                        â–¼             â”‚          â”‚ â”‚
â”‚  â”‚  â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚          â”‚ â”‚
â”‚  â”‚  â”‚                  â”‚ isomorphic-git â”‚  â”‚          â”‚ â”‚
â”‚  â”‚  â”‚                  â”‚ SQLite         â”‚  â”‚          â”‚ â”‚
â”‚  â”‚  â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚          â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### åˆ†å±‚æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Presentation Layer (è¡¨ç°å±‚)            â”‚
â”‚  - React Components                     â”‚
â”‚  - Ant Design UI                        â”‚
â”‚  - ç”¨æˆ·äº¤äº’                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Application Layer (åº”ç”¨å±‚)             â”‚
â”‚  - Services (ä¸šåŠ¡æœåŠ¡)                   â”‚
â”‚  - Stores (çŠ¶æ€ç®¡ç†)                     â”‚
â”‚  - Hooks (è‡ªå®šä¹‰ Hooks)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Domain Layer (é¢†åŸŸå±‚)                  â”‚
â”‚  - Entities (å®ä½“)                      â”‚
â”‚  - Use Cases (ç”¨ä¾‹)                     â”‚
â”‚  - Business Rules (ä¸šåŠ¡è§„åˆ™)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Infrastructure Layer (åŸºç¡€è®¾æ–½å±‚)       â”‚
â”‚  - Git Wrapper (Git å°è£…)              â”‚
â”‚  - File System (æ–‡ä»¶ç³»ç»Ÿ)               â”‚
â”‚  - Database (æ•°æ®åº“)                    â”‚
â”‚  - Cache (ç¼“å­˜)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š æ•°æ®æ¨¡å‹

### æ ¸å¿ƒå®ä½“

#### Repository (ä»“åº“)

```typescript
interface Repository {
  id: string                    // ä»“åº“ ID
  path: string                  // ä»“åº“è·¯å¾„
  name: string                  // ä»“åº“åç§°
  currentBranch: string         // å½“å‰åˆ†æ”¯
  isClean: boolean             // æ˜¯å¦å¹²å‡€ï¼ˆæ— å˜æ›´ï¼‰
  lastOpened: Date             // æœ€åæ‰“å¼€æ—¶é—´
  createdAt: Date              // åˆ›å»ºæ—¶é—´
}
```

#### Snapshot (å¿«ç…§)

```typescript
interface Snapshot {
  id: string                    // å¿«ç…§ ID (commit hash)
  shortId: string              // çŸ­ ID (å‰ 7 ä½)
  message: string              // å¿«ç…§æè¿°
  author: string               // ä½œè€…
  email: string                // é‚®ç®±
  timestamp: Date              // æ—¶é—´æˆ³
  parents: string[]            // çˆ¶å¿«ç…§ ID
  isMerge: boolean             // æ˜¯å¦ä¸ºåˆå¹¶å¿«ç…§
  files: FileChange[]          // æ–‡ä»¶å˜æ›´åˆ—è¡¨
}
```

#### FileChange (æ–‡ä»¶å˜æ›´)

```typescript
interface FileChange {
  path: string                  // æ–‡ä»¶è·¯å¾„
  status: FileStatus           // æ–‡ä»¶çŠ¶æ€
  oldPath?: string             // æ—§è·¯å¾„ï¼ˆé‡å‘½åæ—¶ï¼‰
}

enum FileStatus {
  Added = 'added',             // æ–°å¢
  Modified = 'modified',       // ä¿®æ”¹
  Deleted = 'deleted',         // åˆ é™¤
  Renamed = 'renamed',         // é‡å‘½å
  Copied = 'copied'            // å¤åˆ¶
}
```

#### Branch (åˆ†æ”¯)

```typescript
interface Branch {
  name: string                  // åˆ†æ”¯åç§°
  isCurrent: boolean           // æ˜¯å¦ä¸ºå½“å‰åˆ†æ”¯
  lastCommit: string           // æœ€åä¸€æ¬¡æäº¤ ID
  lastCommitDate: Date         // æœ€åæäº¤æ—¶é—´
}
```

#### FileNode (æ–‡ä»¶æ ‘èŠ‚ç‚¹)

```typescript
interface FileNode {
  id: string                    // èŠ‚ç‚¹ ID
  name: string                  // æ–‡ä»¶/æ–‡ä»¶å¤¹åç§°
  path: string                  // å®Œæ•´è·¯å¾„
  type: 'file' | 'directory'   // ç±»å‹
  status?: FileStatus          // æ–‡ä»¶çŠ¶æ€
  children?: FileNode[]        // å­èŠ‚ç‚¹
  isExpanded?: boolean         // æ˜¯å¦å±•å¼€
  isSelected?: boolean         // æ˜¯å¦é€‰ä¸­
}
```

### æ•°æ®åº“è®¾è®¡ (SQLite)

```sql
-- ä»“åº“è¡¨
CREATE TABLE repositories (
  id TEXT PRIMARY KEY,
  path TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  current_branch TEXT,
  last_opened DATETIME,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- æœ€è¿‘ä½¿ç”¨è¡¨
CREATE TABLE recent_repositories (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  repository_id TEXT NOT NULL,
  opened_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (repository_id) REFERENCES repositories(id)
);

-- æ–‡ä»¶ç¼“å­˜è¡¨
CREATE TABLE file_cache (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  repository_id TEXT NOT NULL,
  file_path TEXT NOT NULL,
  file_hash TEXT,
  cached_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (repository_id) REFERENCES repositories(id)
);

-- é…ç½®è¡¨
CREATE TABLE settings (
  key TEXT PRIMARY KEY,
  value TEXT,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- ç´¢å¼•
CREATE INDEX idx_recent_repos ON recent_repositories(opened_at DESC);
CREATE INDEX idx_file_cache ON file_cache(repository_id, file_path);
```

---


## ğŸ”Œ API è®¾è®¡

### REST API (æœ¬åœ°æ¨¡å¼)

#### ä»“åº“æ“ä½œ

```typescript
// åˆå§‹åŒ–ä»“åº“
POST /api/repository/init
Request: { path: string }
Response: { success: boolean, data: Repository }

// æ‰“å¼€ä»“åº“
POST /api/repository/open
Request: { path: string }
Response: { success: boolean, data: Repository }

// è·å–ä»“åº“çŠ¶æ€
GET /api/repository/status?path={path}
Response: { 
  success: boolean, 
  data: {
    branch: string,
    changes: FileChange[],
    isClean: boolean
  }
}

// è·å–æ–‡ä»¶åˆ—è¡¨
GET /api/repository/files?path={path}
Response: { success: boolean, data: { files: string[] } }
```

#### å¿«ç…§æ“ä½œ

```typescript
// åˆ›å»ºå¿«ç…§
POST /api/repository/commit
Request: { 
  path: string, 
  message: string, 
  files?: string[] 
}
Response: { success: boolean, data: { commitId: string } }

// è·å–å†å²è®°å½•
GET /api/repository/log?path={path}&limit={limit}
Response: { success: boolean, data: { logs: Snapshot[] } }

// å›æ»šåˆ°æŒ‡å®šå¿«ç…§
POST /api/repository/checkout
Request: { path: string, commitId: string }
Response: { success: boolean }
```

#### åˆ†æ”¯æ“ä½œ

```typescript
// è·å–åˆ†æ”¯åˆ—è¡¨
GET /api/repository/branches?path={path}
Response: { 
  success: boolean, 
  data: { 
    branches: Branch[], 
    current: string 
  } 
}

// åˆ›å»ºåˆ†æ”¯
POST /api/repository/branch
Request: { path: string, branchName: string }
Response: { success: boolean }

// åˆ‡æ¢åˆ†æ”¯
POST /api/repository/switch
Request: { path: string, branchName: string }
Response: { success: boolean }

// åˆå¹¶åˆ†æ”¯
POST /api/repository/merge
Request: { 
  path: string, 
  sourceBranch: string, 
  targetBranch?: string 
}
Response: { 
  success: boolean, 
  data: { 
    hasConflicts: boolean, 
    conflicts?: string[] 
  } 
}
```

### IPC API (æ¡Œé¢æ¨¡å¼)

```typescript
// Electron IPC é€šé“
const IPC_CHANNELS = {
  // ä»“åº“æ“ä½œ
  REPO_INIT: 'repo:init',
  REPO_OPEN: 'repo:open',
  REPO_STATUS: 'repo:status',
  REPO_FILES: 'repo:files',
  
  // å¿«ç…§æ“ä½œ
  SNAPSHOT_CREATE: 'snapshot:create',
  SNAPSHOT_LIST: 'snapshot:list',
  SNAPSHOT_CHECKOUT: 'snapshot:checkout',
  
  // åˆ†æ”¯æ“ä½œ
  BRANCH_LIST: 'branch:list',
  BRANCH_CREATE: 'branch:create',
  BRANCH_SWITCH: 'branch:switch',
  BRANCH_MERGE: 'branch:merge',
  
  // æ–‡ä»¶æ“ä½œ
  FILE_SELECT: 'file:select',
  FILE_WATCH: 'file:watch',
}
```

---

## ğŸ¨ ç»„ä»¶è®¾è®¡

### å‰ç«¯ç»„ä»¶æ ‘

```
App
â”œâ”€â”€ HomePage
â”‚   â”œâ”€â”€ RecentRepositories
â”‚   â””â”€â”€ OpenRepositoryButton
â”‚
â””â”€â”€ RepositoryPage
    â”œâ”€â”€ Header
    â”‚   â”œâ”€â”€ BackButton
    â”‚   â”œâ”€â”€ RefreshButton
    â”‚   â”œâ”€â”€ CreateSnapshotButton
    â”‚   â””â”€â”€ HelpButton
    â”‚
    â”œâ”€â”€ LeftPanel (40%)
    â”‚   â”œâ”€â”€ RepositoryStatus
    â”‚   â”‚   â”œâ”€â”€ CurrentBranch
    â”‚   â”‚   â”œâ”€â”€ RepositoryPath
    â”‚   â”‚   â””â”€â”€ PendingChanges
    â”‚   â”‚
    â”‚   â”œâ”€â”€ FileTree
    â”‚   â”‚   â””â”€â”€ TreeNode (é€’å½’)
    â”‚   â”‚       â”œâ”€â”€ FileIcon
    â”‚   â”‚       â”œâ”€â”€ FileName
    â”‚   â”‚       â”œâ”€â”€ FileStatus
    â”‚   â”‚       â””â”€â”€ Checkbox
    â”‚   â”‚
    â”‚   â””â”€â”€ BranchManager
    â”‚       â”œâ”€â”€ BranchList
    â”‚       â”œâ”€â”€ CreateBranchButton
    â”‚       â”œâ”€â”€ SwitchBranchButton
    â”‚       â””â”€â”€ MergeBranchButton
    â”‚
    â””â”€â”€ RightPanel (60%)
        â””â”€â”€ HistoryViewer
            â””â”€â”€ SnapshotList (è™šæ‹Ÿæ»šåŠ¨)
                â””â”€â”€ SnapshotItem
                    â”œâ”€â”€ SnapshotInfo
                    â”œâ”€â”€ SnapshotFiles
                    â””â”€â”€ CheckoutButton
```

### æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### FileTree ç»„ä»¶

```typescript
interface FileTreeProps {
  files: FileNode[]
  selectedFiles: Set<string>
  onSelect: (files: Set<string>) => void
  onExpand: (nodeId: string) => void
}

// ä½¿ç”¨ react-window å®ç°è™šæ‹Ÿæ»šåŠ¨
const FileTree: React.FC<FileTreeProps> = ({ files, selectedFiles, onSelect, onExpand }) => {
  const flattenedNodes = useMemo(() => flattenTree(files), [files])
  
  return (
    <FixedSizeList
      height={600}
      itemCount={flattenedNodes.length}
      itemSize={32}
      width="100%"
    >
      {({ index, style }) => (
        <TreeNode
          node={flattenedNodes[index]}
          style={style}
          isSelected={selectedFiles.has(flattenedNodes[index].path)}
          onSelect={onSelect}
          onExpand={onExpand}
        />
      )}
    </FixedSizeList>
  )
}
```

#### HistoryViewer ç»„ä»¶

```typescript
interface HistoryViewerProps {
  snapshots: Snapshot[]
  onCheckout: (snapshotId: string) => void
  loading: boolean
}

const HistoryViewer: React.FC<HistoryViewerProps> = ({ snapshots, onCheckout, loading }) => {
  return (
    <div className="history-viewer">
      <Timeline>
        {snapshots.map(snapshot => (
          <Timeline.Item key={snapshot.id}>
            <SnapshotCard
              snapshot={snapshot}
              onCheckout={onCheckout}
            />
          </Timeline.Item>
        ))}
      </Timeline>
    </div>
  )
}
```

---

## ğŸ”§ æœåŠ¡è®¾è®¡

### GitService (Git æ“ä½œæœåŠ¡)

ä½¿ç”¨ **isomorphic-git** å®ç°ï¼Œå®Œå…¨å†…ç½®ï¼Œæ— éœ€ç”¨æˆ·å®‰è£… Gitã€‚

```typescript
import git from 'isomorphic-git'
import fs from 'fs'
import path from 'path'

class GitService {
  /**
   * åˆå§‹åŒ–ä»“åº“
   */
  async init(repoPath: string): Promise<void> {
    await git.init({
      fs,
      dir: repoPath,
      defaultBranch: 'main'
    })
    
    // åˆ›å»ºé»˜è®¤ .gitignore
    await this.createDefaultGitignore(repoPath)
    
    // é…ç½®ç”¨æˆ·ä¿¡æ¯
    await git.setConfig({
      fs,
      dir: repoPath,
      path: 'user.name',
      value: 'Chronos User'
    })
    
    await git.setConfig({
      fs,
      dir: repoPath,
      path: 'user.email',
      value: 'user@chronos.local'
    })
  }
  
  /**
   * è·å–ä»“åº“çŠ¶æ€
   */
  async getStatus(repoPath: string): Promise<RepositoryStatus> {
    const status = await git.statusMatrix({
      fs,
      dir: repoPath
    })
    
    const changes: FileChange[] = []
    
    for (const [filepath, headStatus, workdirStatus, stageStatus] of status) {
      // è·³è¿‡æœªä¿®æ”¹çš„æ–‡ä»¶
      if (headStatus === 1 && workdirStatus === 1 && stageStatus === 1) {
        continue
      }
      
      let fileStatus: FileStatus
      if (headStatus === 0) {
        fileStatus = FileStatus.Added
      } else if (workdirStatus === 0) {
        fileStatus = FileStatus.Deleted
      } else {
        fileStatus = FileStatus.Modified
      }
      
      changes.push({ path: filepath, status: fileStatus })
    }
    
    const currentBranch = await git.currentBranch({
      fs,
      dir: repoPath,
      fullname: false
    })
    
    return {
      branch: currentBranch || 'main',
      changes,
      isClean: changes.length === 0
    }
  }
  
  /**
   * åˆ›å»ºå¿«ç…§
   */
  async createCommit(
    repoPath: string, 
    message: string, 
    files?: string[]
  ): Promise<string> {
    // æ·»åŠ æ–‡ä»¶
    if (files && files.length > 0) {
      for (const file of files) {
        await git.add({ fs, dir: repoPath, filepath: file })
      }
    } else {
      // æ·»åŠ æ‰€æœ‰å˜æ›´æ–‡ä»¶
      const status = await git.statusMatrix({ fs, dir: repoPath })
      for (const [filepath] of status) {
        await git.add({ fs, dir: repoPath, filepath })
      }
    }
    
    // åˆ›å»ºæäº¤
    const commitId = await git.commit({
      fs,
      dir: repoPath,
      message,
      author: {
        name: 'Chronos User',
        email: 'user@chronos.local'
      }
    })
    
    return commitId
  }
  
  /**
   * è·å–å†å²è®°å½•
   */
  async getLog(repoPath: string, limit?: number): Promise<Snapshot[]> {
    const commits = await git.log({
      fs,
      dir: repoPath,
      depth: limit
    })
    
    return commits.map(commit => ({
      id: commit.oid,
      shortId: commit.oid.substring(0, 7),
      message: commit.commit.message,
      author: commit.commit.author.name,
      email: commit.commit.author.email,
      timestamp: new Date(commit.commit.author.timestamp * 1000),
      parents: commit.commit.parent,
      isMerge: commit.commit.parent.length > 1,
      files: [] // éœ€è¦å•ç‹¬è·å–
    }))
  }
  
  /**
   * å›æ»šåˆ°æŒ‡å®šå¿«ç…§
   */
  async checkout(repoPath: string, commitId: string): Promise<void> {
    await git.checkout({
      fs,
      dir: repoPath,
      ref: commitId,
      force: true
    })
  }
  
  /**
   * è·å–åˆ†æ”¯åˆ—è¡¨
   */
  async getBranches(repoPath: string): Promise<Branch[]> {
    const branches = await git.listBranches({
      fs,
      dir: repoPath
    })
    
    const currentBranch = await git.currentBranch({
      fs,
      dir: repoPath,
      fullname: false
    })
    
    return branches.map(name => ({
      name,
      isCurrent: name === currentBranch,
      lastCommit: '', // éœ€è¦å•ç‹¬è·å–
      lastCommitDate: new Date()
    }))
  }
  
  /**
   * åˆ›å»ºåˆ†æ”¯
   */
  async createBranch(repoPath: string, branchName: string): Promise<void> {
    await git.branch({
      fs,
      dir: repoPath,
      ref: branchName
    })
    
    await git.checkout({
      fs,
      dir: repoPath,
      ref: branchName
    })
  }
  
  /**
   * åˆ‡æ¢åˆ†æ”¯
   */
  async switchBranch(repoPath: string, branchName: string): Promise<void> {
    await git.checkout({
      fs,
      dir: repoPath,
      ref: branchName
    })
  }
  
  /**
   * åˆå¹¶åˆ†æ”¯
   */
  async mergeBranch(
    repoPath: string, 
    sourceBranch: string, 
    targetBranch?: string
  ): Promise<MergeResult> {
    if (targetBranch) {
      await this.switchBranch(repoPath, targetBranch)
    }
    
    try {
      await git.merge({
        fs,
        dir: repoPath,
        ours: targetBranch || await git.currentBranch({ fs, dir: repoPath }),
        theirs: sourceBranch,
        author: {
          name: 'Chronos User',
          email: 'user@chronos.local'
        }
      })
      
      return { hasConflicts: false }
    } catch (error) {
      // æ£€æŸ¥æ˜¯å¦æœ‰å†²çª
      const conflicts = await this.getConflicts(repoPath)
      return { hasConflicts: true, conflicts }
    }
  }
  
  /**
   * åˆ›å»ºé»˜è®¤ .gitignore
   */
  private async createDefaultGitignore(repoPath: string): Promise<void> {
    const gitignoreContent = `
# System Files
.DS_Store
Thumbs.db
desktop.ini

# IDE
.vscode/
.idea/
*.swp
*.swo

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Dependencies
node_modules/
`.trim()
    
    const gitignorePath = path.join(repoPath, '.gitignore')
    await fs.promises.writeFile(gitignorePath, gitignoreContent, 'utf-8')
  }
  
  /**
   * è·å–å†²çªæ–‡ä»¶åˆ—è¡¨
   */
  private async getConflicts(repoPath: string): Promise<string[]> {
    const status = await git.statusMatrix({ fs, dir: repoPath })
    const conflicts: string[] = []
    
    for (const [filepath, headStatus, workdirStatus, stageStatus] of status) {
      // æ£€æµ‹å†²çªçŠ¶æ€
      if (stageStatus === 2) {
        conflicts.push(filepath)
      }
    }
    
    return conflicts
  }
}
```

**ä¼˜åŠ¿**ï¼š
- âœ… å®Œå…¨å†…ç½®ï¼Œæ— éœ€ç”¨æˆ·å®‰è£… Git
- âœ… è·¨å¹³å°æ”¯æŒï¼ˆWindows + macOS + Linux + æµè§ˆå™¨ï¼‰
- âœ… ç»Ÿä¸€çš„ APIï¼Œé™ä½å¤æ‚åº¦
- âœ… æ€§èƒ½è¶³å¤Ÿå¥½ï¼ˆå¯¹äºæœ¬åœ°æ–‡ä»¶æ“ä½œï¼‰

### FileService (æ–‡ä»¶æ“ä½œæœåŠ¡)

```typescript
class FileService {
  private watcher: FSWatcher | null = null
  
  /**
   * æ‰«ææ–‡ä»¶å¤¹
   */
  async scanDirectory(path: string): Promise<FileNode[]> {
    const entries = await fs.readdir(path, { withFileTypes: true })
    const nodes: FileNode[] = []
    
    for (const entry of entries) {
      // è·³è¿‡ç³»ç»Ÿæ–‡ä»¶
      if (this.isSystemFile(entry.name)) continue
      
      const fullPath = join(path, entry.name)
      const node: FileNode = {
        id: fullPath,
        name: entry.name,
        path: fullPath,
        type: entry.isDirectory() ? 'directory' : 'file',
      }
      
      if (entry.isDirectory()) {
        node.children = await this.scanDirectory(fullPath)
      }
      
      nodes.push(node)
    }
    
    return nodes
  }
  
  /**
   * ç›‘å¬æ–‡ä»¶å˜åŒ–
   */
  watchDirectory(path: string, callback: (event: string, path: string) => void): void {
    this.watcher = chokidar.watch(path, {
      ignored: /(^|[\/\\])\../, // å¿½ç•¥éšè—æ–‡ä»¶
      persistent: true,
      ignoreInitial: true,
    })
    
    this.watcher
      .on('add', path => callback('add', path))
      .on('change', path => callback('change', path))
      .on('unlink', path => callback('unlink', path))
  }
  
  /**
   * åœæ­¢ç›‘å¬
   */
  unwatchDirectory(): void {
    if (this.watcher) {
      this.watcher.close()
      this.watcher = null
    }
  }
  
  /**
   * åˆ¤æ–­æ˜¯å¦ä¸ºç³»ç»Ÿæ–‡ä»¶
   */
  private isSystemFile(name: string): boolean {
    const systemFiles = [
      '.DS_Store',
      'Thumbs.db',
      'desktop.ini',
      '.git',
      'node_modules',
    ]
    return systemFiles.includes(name)
  }
}
```

### DatabaseService (æ•°æ®åº“æœåŠ¡)

```typescript
class DatabaseService {
  private db: Database
  
  constructor(dbPath: string) {
    this.db = new Database(dbPath)
    this.init()
  }
  
  /**
   * åˆå§‹åŒ–æ•°æ®åº“
   */
  private init(): void {
    // åˆ›å»ºè¡¨
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS repositories (
        id TEXT PRIMARY KEY,
        path TEXT UNIQUE NOT NULL,
        name TEXT NOT NULL,
        current_branch TEXT,
        last_opened DATETIME,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `)
    
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS recent_repositories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        repository_id TEXT NOT NULL,
        opened_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (repository_id) REFERENCES repositories(id)
      )
    `)
  }
  
  /**
   * ä¿å­˜ä»“åº“
   */
  saveRepository(repo: Repository): void {
    const stmt = this.db.prepare(`
      INSERT OR REPLACE INTO repositories 
      (id, path, name, current_branch, last_opened)
      VALUES (?, ?, ?, ?, ?)
    `)
    
    stmt.run(
      repo.id,
      repo.path,
      repo.name,
      repo.currentBranch,
      repo.lastOpened.toISOString()
    )
  }
  
  /**
   * è·å–æœ€è¿‘ä½¿ç”¨çš„ä»“åº“
   */
  getRecentRepositories(limit: number = 10): Repository[] {
    const stmt = this.db.prepare(`
      SELECT r.* FROM repositories r
      JOIN recent_repositories rr ON r.id = rr.repository_id
      ORDER BY rr.opened_at DESC
      LIMIT ?
    `)
    
    return stmt.all(limit) as Repository[]
  }
  
  /**
   * è®°å½•ä»“åº“æ‰“å¼€
   */
  recordRepositoryOpen(repositoryId: string): void {
    const stmt = this.db.prepare(`
      INSERT INTO recent_repositories (repository_id)
      VALUES (?)
    `)
    
    stmt.run(repositoryId)
  }
}
```

---

## ğŸ¯ çŠ¶æ€ç®¡ç† (Zustand)

### RepositoryStore

```typescript
interface RepositoryState {
  // çŠ¶æ€
  currentRepository: Repository | null
  status: RepositoryStatus | null
  files: FileNode[]
  selectedFiles: Set<string>
  loading: boolean
  error: string | null
  
  // æ“ä½œ
  openRepository: (path: string) => Promise<void>
  refreshStatus: () => Promise<void>
  selectFiles: (files: Set<string>) => void
  createSnapshot: (message: string) => Promise<void>
}

const useRepositoryStore = create<RepositoryState>((set, get) => ({
  currentRepository: null,
  status: null,
  files: [],
  selectedFiles: new Set(),
  loading: false,
  error: null,
  
  openRepository: async (path: string) => {
    set({ loading: true, error: null })
    try {
      const repo = await apiService.openRepository(path)
      const status = await apiService.getStatus(path)
      const files = await fileService.scanDirectory(path)
      
      set({
        currentRepository: repo,
        status,
        files,
        loading: false,
      })
    } catch (error) {
      set({ error: error.message, loading: false })
    }
  },
  
  refreshStatus: async () => {
    const { currentRepository } = get()
    if (!currentRepository) return
    
    const status = await apiService.getStatus(currentRepository.path)
    set({ status })
  },
  
  selectFiles: (files: Set<string>) => {
    set({ selectedFiles: files })
  },
  
  createSnapshot: async (message: string) => {
    const { currentRepository, selectedFiles } = get()
    if (!currentRepository) return
    
    set({ loading: true })
    try {
      await apiService.createSnapshot(
        currentRepository.path,
        message,
        Array.from(selectedFiles)
      )
      await get().refreshStatus()
      set({ selectedFiles: new Set(), loading: false })
    } catch (error) {
      set({ error: error.message, loading: false })
    }
  },
}))
```

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### æ–‡ä»¶æ‰«æä¼˜åŒ–

```typescript
// ä½¿ç”¨ Worker çº¿ç¨‹è¿›è¡Œæ–‡ä»¶æ‰«æ
// src/server/workers/file-scanner.ts
import { parentPort } from 'worker_threads'

parentPort?.on('message', async ({ path }) => {
  const files = await scanDirectory(path)
  parentPort?.postMessage({ files })
})

// ä¸»çº¿ç¨‹ä½¿ç”¨
const worker = new Worker('./workers/file-scanner.js')
worker.postMessage({ path: '/path/to/repo' })
worker.on('message', ({ files }) => {
  // å¤„ç†ç»“æœ
})
```

### è™šæ‹Ÿæ»šåŠ¨

```typescript
// ä½¿ç”¨ react-window å®ç°è™šæ‹Ÿæ»šåŠ¨
import { FixedSizeList } from 'react-window'

const FileList: React.FC = ({ files }) => {
  return (
    <FixedSizeList
      height={600}
      itemCount={files.length}
      itemSize={32}
      width="100%"
    >
      {({ index, style }) => (
        <div style={style}>
          {files[index].name}
        </div>
      )}
    </FixedSizeList>
  )
}
```

### ç¼“å­˜ç­–ç•¥

```typescript
// LRU ç¼“å­˜
import LRU from 'lru-cache'

const fileCache = new LRU<string, FileNode[]>({
  max: 100,
  ttl: 1000 * 60 * 5, // 5 åˆ†é’Ÿ
})

async function getFiles(path: string): Promise<FileNode[]> {
  const cached = fileCache.get(path)
  if (cached) return cached
  
  const files = await scanDirectory(path)
  fileCache.set(path, files)
  return files
}
```

---

## ğŸ§ª æµ‹è¯•è®¾è®¡

### å•å…ƒæµ‹è¯•

```typescript
// GitService æµ‹è¯•
describe('GitService', () => {
  let gitService: GitService
  let testRepo: string
  
  beforeEach(async () => {
    gitService = new GitService()
    testRepo = await createTestRepository()
  })
  
  afterEach(async () => {
    await cleanupTestRepository(testRepo)
  })
  
  it('should init repository', async () => {
    await gitService.init(testRepo)
    const exists = await fs.pathExists(join(testRepo, '.git'))
    expect(exists).toBe(true)
  })
  
  it('should create commit', async () => {
    await gitService.init(testRepo)
    await fs.writeFile(join(testRepo, 'test.txt'), 'test')
    const commitId = await gitService.createCommit(testRepo, 'test commit')
    expect(commitId).toBeTruthy()
  })
})
```

### é›†æˆæµ‹è¯•

```typescript
// API é›†æˆæµ‹è¯•
describe('Repository API', () => {
  it('POST /api/repository/init', async () => {
    const response = await request(app)
      .post('/api/repository/init')
      .send({ path: '/tmp/test-repo' })
    
    expect(response.status).toBe(200)
    expect(response.body.success).toBe(true)
  })
})
```

### E2E æµ‹è¯•

```typescript
// Playwright E2E æµ‹è¯•
test('create snapshot flow', async ({ page }) => {
  await page.goto('http://localhost:3000')
  
  // æ‰“å¼€ä»“åº“
  await page.click('text=æ‰“å¼€æ–‡ä»¶å¤¹')
  // ... é€‰æ‹©æ–‡ä»¶å¤¹
  
  // åˆ›å»ºå¿«ç…§
  await page.click('text=åˆ›å»ºå¿«ç…§')
  await page.fill('input[name="message"]', 'test snapshot')
  await page.click('text=ç¡®è®¤')
  
  // éªŒè¯
  await expect(page.locator('text=åˆ›å»ºæˆåŠŸ')).toBeVisible()
})
```

---

## ğŸ“ é”™è¯¯å¤„ç†

### é”™è¯¯ç±»å‹å®šä¹‰

```typescript
class AppError extends Error {
  constructor(
    public code: string,
    public message: string,
    public details?: any
  ) {
    super(message)
    this.name = 'AppError'
  }
}

// é”™è¯¯ç 
const ErrorCodes = {
  REPO_NOT_FOUND: 'REPO_NOT_FOUND',
  REPO_NOT_INITIALIZED: 'REPO_NOT_INITIALIZED',
  INVALID_PATH: 'INVALID_PATH',
  GIT_ERROR: 'GIT_ERROR',
  FILE_NOT_FOUND: 'FILE_NOT_FOUND',
  MERGE_CONFLICT: 'MERGE_CONFLICT',
}
```

### é”™è¯¯å¤„ç†ä¸­é—´ä»¶

```typescript
// Express é”™è¯¯å¤„ç†ä¸­é—´ä»¶
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  logger.error('API Error:', err)
  
  if (err instanceof AppError) {
    return res.status(400).json({
      success: false,
      error: err.message,
      code: err.code,
      details: err.details,
    })
  }
  
  res.status(500).json({
    success: false,
    error: 'æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•',
  })
})
```

---

## ğŸ”’ å®‰å…¨è€ƒè™‘

### è·¯å¾„éªŒè¯

```typescript
function validatePath(path: string): void {
  // æ£€æŸ¥è·¯å¾„æ˜¯å¦å­˜åœ¨
  if (!fs.existsSync(path)) {
    throw new AppError('INVALID_PATH', 'è·¯å¾„ä¸å­˜åœ¨')
  }
  
  // æ£€æŸ¥è·¯å¾„æ˜¯å¦ä¸ºç›®å½•
  if (!fs.statSync(path).isDirectory()) {
    throw new AppError('INVALID_PATH', 'è·¯å¾„å¿…é¡»æ˜¯æ–‡ä»¶å¤¹')
  }
  
  // é˜²æ­¢è·¯å¾„éå†æ”»å‡»
  const normalized = path.normalize(path)
  if (normalized.includes('..')) {
    throw new AppError('INVALID_PATH', 'éæ³•è·¯å¾„')
  }
}
```

### è¾“å…¥éªŒè¯

```typescript
// ä½¿ç”¨ Zod è¿›è¡Œè¾“å…¥éªŒè¯
import { z } from 'zod'

const CreateSnapshotSchema = z.object({
  path: z.string().min(1),
  message: z.string().min(1).max(500),
  files: z.array(z.string()).optional(),
})

app.post('/api/repository/commit', async (req, res) => {
  const validated = CreateSnapshotSchema.parse(req.body)
  // å¤„ç†è¯·æ±‚
})
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-11-02  
**ä½œè€…**: Kiro AI Assistant  
**å®¡æ ¸çŠ¶æ€**: å¾…å®¡æ ¸
